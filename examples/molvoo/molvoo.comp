#version 450

layout (push_constant) uniform ComputeUniform {
  vec3 rayStart;
  float timeStep;
  vec3 rayDir;
  uint numAtoms;
  uint numConnections;
  uint pickIndex;
  uint pass;
} u;

struct Atom {
  vec3 pos;
  float radius;
  vec3 colour;
  float mass;
  vec3 velocity;
  int pad;
  vec3 acceleration;
  int pad2;
};

struct Connection {
  uint from;
  uint to;
  float naturalLength;
  float springConstant;
};

struct rsResult {
  vec3 pos;
  bool collides;
  float t;
};

rsResult raySphereCollide(vec3 rayDir, vec3 centre, float radius) {
  const float a = 1.0;
  float b = -2.0 * dot(centre, rayDir);
  float c = dot(centre, centre) - radius * radius;
  float q = b * b - (4.0 * a) * c;
  float t = (-b - sqrt(q)) * 0.5;
  rsResult res;
  res.pos = rayDir * t;
  res.collides = q >= 0 && t > 0;
  res.t = t;
  return res;
}

layout(std430, binding=0) buffer Atoms {
  Atom atoms[];
} a;

struct Pick {
  uint atom;
  uint distance;
};

layout(std430, binding=2) buffer Picks {
  Pick picks[];
} pick;

layout(std430, binding=3) buffer Connections {
  Connection conns[];
} c;

layout (local_size_x = 64) in;

void main() {
  uint id = gl_GlobalInvocationID.x;
  if (u.pass == 0 && id < u.numConnections) {
    // Velocity update step.
    Connection conn = c.conns[id];
    vec3 p1 = a.atoms[conn.from].pos;
    vec3 p2 = a.atoms[conn.to].pos;
    vec3 v1 = a.atoms[conn.from].velocity;
    vec3 v2 = a.atoms[conn.to].velocity;
    float len = length(p2 - p1);
    vec3 axis = normalize(p2 - p1);
    float f = conn.springConstant * (len - conn.naturalLength);
    a.atoms[conn.from].velocity += axis * (f * u.timeStep / a.atoms[conn.from].mass);
    a.atoms[conn.to].velocity -= axis * (f * u.timeStep / a.atoms[conn.to].mass);
  }

  if (id < u.numAtoms) {
    Atom atom = a.atoms[id];

    rsResult res = raySphereCollide(u.rayDir, atom.pos - u.rayStart, atom.radius);
    if (res.collides) {
      uint distance = uint(res.t * 10000);
      uint mind = atomicMin(pick.picks[u.pickIndex].distance, distance);

      // This only happens in pass 2
      if (distance == mind) pick.picks[u.pickIndex].atom = id;
    }

    if (u.pass == 1) {
      // Position update step.
      a.atoms[id].pos += atom.velocity * u.timeStep;
      a.atoms[id].velocity *= 0.99f;
    }
  }
}
